"BookingApplication.java"
package com.booking;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

/**
 * Main class for starting the Booking and Payment Processing Spring Boot application.
 * 
 * This service is registered with Eureka and uses Feign clients for communication 
 * with external services like Travel Package, User Management, and Insurance modules.
 */
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients(basePackages = "com.booking.client")
public class BookingApplication {

    /**
     * Main method to bootstrap the Spring Boot application.
     * 
     * @param args Command-line arguments
     */
    public static void main(String[] args) {
        SpringApplication.run(BookingApplication.class, args);
    }
}


"TravelInsuranceClient.java"
package com.booking.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;

/**
 * Feign client for interacting with the Travel Insurance Service.
 * 
 * This client provides methods to retrieve insurance prices, validate insurance,
 * and update booking IDs for insurance records.
 */
@FeignClient(name = "TravelInsuranceService", url = "http://localhost:8085")
public interface TravelInsuranceClient {

    /**
     * Retrieve the insurance price for a specific user.
     * 
     * @param userId The ID of the user.
     * @return The insurance price for the user.
     */
    @GetMapping("/api/insurance/price/user/{userId}")
    double getInsurancePriceByUserId(@PathVariable("userId") Long userId);

    /**
     * Retrieve the insurance price for a specific insurance ID.
     * 
     * @param insuranceId The ID of the insurance.
     * @return The insurance price for the insurance ID.
     */
    @GetMapping("/api/insurance/price/insurance/{insuranceId}")
    double getInsurancePriceByInsuranceId(@PathVariable("insuranceId") Integer insuranceId);

    /**
     * Validate the insurance by its ID.
     * 
     * @param insuranceId The ID of the insurance to be validated.
     * @return true if the insurance is valid, false otherwise.
     */
    @GetMapping("/api/insurance/validate/{insuranceId}")
    boolean validateInsurance(@PathVariable("insuranceId") Integer insuranceId);

    /**
     * Update the booking ID for a specific insurance record.
     * 
     * @param insuranceId The ID of the insurance.
     * @param bookingId The ID of the booking.
     * @return A message indicating the result of the update operation.
     */
    @PutMapping("/api/insurance/{insuranceId}/booking/{bookingId}")
    String updateInsuranceBookingId(@PathVariable("insuranceId") Integer insuranceId, @PathVariable("bookingId") Long bookingId);
}

"TravelPackageClient.java"
package com.booking.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import com.booking.dto.TravelPackageDTO;

import java.util.List;

/**
 * Feign client for interacting with the Travel Package Management Service.
 * 
 * This client provides methods to retrieve all travel packages and to get a specific package by its ID.
 */
@FeignClient(name = "travel-package-management")
public interface TravelPackageClient {

    /**
     * Retrieve all travel packages.
     * 
     * @return A list of TravelPackageDTO representing all travel packages.
     */
    @GetMapping("/api/packages/internal/all")
    List<TravelPackageDTO> getAllPackages();

    /**
     * Retrieve a travel package by its ID.
     * 
     * @param id The ID of the travel package to be retrieved.
     * @return The TravelPackageDTO representing the travel package.
     */
    @GetMapping("/api/packages/internal/{id}")
    TravelPackageDTO getPackageById(@PathVariable("id") Long id);
}


"UserClient.java"
package com.booking.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import com.booking.dto.UserDTO;

/**
 * Feign client for interacting with the User Management Service.
 * 
 * This client provides methods to retrieve user details by their ID.
 */
@FeignClient(name = "usermanagement-service")
public interface UserClient {

    /**
     * Retrieve customer details by their ID.
     * 
     * @param userId The ID of the customer to be retrieved.
     * @return The UserDTO representing the customer details.
     */
    @GetMapping("/api/users/internal/customer/{id}")
    UserDTO getCustomerById(@PathVariable("id") Long userId);

    // Uncomment the following method if you need to retrieve agent details by their ID.
    // /**
    //  * Retrieve agent details by their ID.
    //  * 
    //  * @param agentId The ID of the agent to be retrieved.
    //  * @return The UserDTO representing the agent details.
    //  */
    // @GetMapping("/api/users/internal/agent/{id}")
    // UserDTO getAgentById(@PathVariable("id") Long agentId); 
}

"BookingController.java"
package com.booking.controller;

import com.booking.dto.BookingDTO;
import com.booking.entity.Booking;
import com.booking.service.BookingService;
import com.booking.response.ApiResponse;
import com.booking.dto.TravelPackageDTO;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.logging.Logger;

/**
 * Controller for handling booking-related requests.
 * 
 * This controller provides endpoints for creating, retrieving, updating, and deleting bookings.
 */
@CrossOrigin(origins = "http://localhost:4200")
@RestController
@RequestMapping("/api/bookings")
public class BookingController {

    private final BookingService service;
    private static final Logger logger = Logger.getLogger(BookingController.class.getName());

    /**
     * Constructor for BookingController.
     * 
     * @param service The BookingService instance to be used by this controller.
     */
    public BookingController(BookingService service) {
        this.service = service;
    }

    /**
     * Create a new booking.
     * 
     * @param booking The booking entity to be created.
     * @return ResponseEntity containing the created BookingDTO and HTTP status.
     */
    @PostMapping
    public ResponseEntity<BookingDTO> createBooking(@RequestBody Booking booking) {
        try {
            BookingDTO bookingDTO = service.createBooking(booking);
            return new ResponseEntity<>(bookingDTO, HttpStatus.CREATED);
        } catch (RuntimeException ex) {
            logger.severe("Error creating booking: " + ex.getMessage());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
        }
    }

    /**
     * Retrieve all bookings.
     * 
     * @return ResponseEntity containing the list of all bookings and HTTP status.
     */
    @GetMapping
    public ResponseEntity<List<Booking>> getAllBookings() {
        List<Booking> bookings = service.getAllBookings();
        return ResponseEntity.ok(bookings);
    }

    /**
     * Retrieve a booking by its ID.
     * 
     * @param id The ID of the booking to be retrieved.
     * @return ResponseEntity containing the booking and HTTP status.
     */
    @GetMapping("/{id}")
    public ResponseEntity<Booking> getBookingById(@PathVariable Long id) {
        Booking booking = service.getBookingById(id);
        if (booking == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(booking);
    }

    /**
     * Cancel a booking by its ID.
     * 
     * @param id The ID of the booking to be canceled.
     * @return ResponseEntity containing the cancellation status and HTTP status.
     */
    @PutMapping("/cancel/{id}")
    public ResponseEntity<String> cancelBooking(@PathVariable Long id) {
        return service.cancelBooking(id);
    }

    /**
     * Delete a booking by its ID.
     * 
     * @param id The ID of the booking to be deleted.
     */
    @DeleteMapping("/{id}")
    public void delete(@PathVariable Long id) {
        service.deleteBooking(id);
    }

    /**
     * Retrieve bookings by user ID.
     * 
     * @param userId The ID of the user whose bookings are to be retrieved.
     * @return ResponseEntity containing the list of bookings and HTTP status.
     */
    @GetMapping("/internal/bookings/user/{userId}")
    public ResponseEntity<List<Booking>> getBookingsByUserId(@PathVariable Long userId) {
        List<Booking> bookings = service.getBookingsByUserId(userId);
        if (bookings.isEmpty()) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(bookings);
    }
    /**
     * Check if a user has completed a package.
     * 
     * @param userId The ID of the user.
     * @param packageId The ID of the package.
     * @return boolean indicating whether the user has completed the package.
     */
    @GetMapping("/user/{userId}/package/{packageId}/completed")
    public boolean hasUserCompletedPackage(@PathVariable Long userId, @PathVariable String packageId) {
        return service.hasUserCompletedPackage(userId, packageId);
    }

    /**
     * Retrieve a booking by its ID for internal use.
     * 
     * @param id The ID of the booking to be retrieved.
     * @return ResponseEntity containing the booking and HTTP status.
     */
    @GetMapping("/internal/{id}")
    public ResponseEntity<Booking> getInternalBookingById(@PathVariable Long id) {
        Booking booking = service.getBookingById(id);
        if (booking == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(booking);
    }

    /**
     * Retrieve all travel packages.
     * 
     * @return ResponseEntity containing the ApiResponse with the list of packages and HTTP status.
     */
    @GetMapping("/packages")
    public ResponseEntity<ApiResponse> getAllPackages() {
        List<TravelPackageDTO> packages = service.getAllPackages();
        return ResponseEntity.ok(new ApiResponse(true, "All packages retrieved", packages));
    }

    /**
     * Retrieve a travel package by its ID.
     * 
     * @param packageId The ID of the package to be retrieved.
     * @return ResponseEntity containing the ApiResponse with the package details and HTTP status.
     */
    @GetMapping("/packages/{id}")
    public ResponseEntity<ApiResponse> getPackageById(@PathVariable("id") Long packageId) {
        TravelPackageDTO packages = service.getPackageById(packageId);
        return ResponseEntity.ok(new ApiResponse(true, "Package retrieved successfully", packages));
    }
}

"PaymentController.java"
package com.booking.controller;

import com.booking.dto.PaymentResponseDTO;
import com.booking.entity.Payment;
import com.booking.service.PaymentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 * Controller for handling payment-related requests.
 * 
 * This controller provides end-points for processing payments, calculating expected totals,
 * and retrieving payment details.
 */
@RestController
@RequestMapping("/api/payments")
public class PaymentController {

    @Autowired
    private PaymentService paymentService;

    /**
     * Process a payment with an optional coupon code.
     * 
     * @param payment The payment entity to be processed.
     * @param couponCode The optional coupon code for discount.
     * @return PaymentResponseDTO containing the details of the processed payment.
     */
    @PostMapping
    public PaymentResponseDTO process(
            @RequestBody Payment payment,
            @RequestParam(required = false) String couponCode) {

        Payment savedPayment = paymentService.processPayment(payment, couponCode);

        PaymentResponseDTO response = new PaymentResponseDTO();
        response.setPaymentId(savedPayment.getPaymentId());
        response.setUserId(savedPayment.getUserId());
        response.setBookingId(savedPayment.getBookingId());
        response.setAmount(savedPayment.getAmount());
        response.setStatus(savedPayment.getStatus());
        response.setPaymentMethod(savedPayment.getPaymentMethod());
        response.setCurrency(savedPayment.getCurrency());

        return response;
    }

    /**
     * Calculate the total payable amount before actual payment.
     * 
     * @param bookingId The ID of the booking.
     * @param couponCode The optional coupon code for discount.
     * @return A map containing the total payable amount.
     */
    @GetMapping("/expected-total")
    public Map<String, Double> getExpectedTotal(
            @RequestParam Long bookingId,
            @RequestParam(required = false) String couponCode) {

        double total = paymentService.calculateExpectedTotal(bookingId, couponCode);
        return Collections.singletonMap("totalPayable", total);
    }

    /**
     * Retrieve all payments.
     * 
     * @return A list of all payments.
     */
    @GetMapping
    public List<Payment> getAll() {
        return paymentService.getAllPayments();
    }

    /**
     * Retrieve a payment by its ID.
     * 
     * @param id The ID of the payment to be retrieved.
     * @return The payment entity.
     */
    @GetMapping("/{id}")
    public Payment getById(@PathVariable Long id) {
        return paymentService.getPaymentById(id);
    }
}

"BookingDTO.java"
package com.booking.dto;

import lombok.Data;
import java.time.LocalDate;

/**
 * Data Transfer Object for booking.
 * Used to transfer booking data between different layers of the application.
 */
@Data
public class BookingDTO {
    private Long bookingId;
    private Long userId;
    private Long packageId;
    private LocalDate tripStartDate;
    private LocalDate tripEndDate;
    private String status;
    private Long paymentId;
	private Integer insuranceId;
		
}


"InsuranceRequestDTO.java"
package com.booking.dto;

import lombok.Data;
 
/**
 * DTO to carry insurance-related data between the Booking module and the Insurance module.
 */
@Data
public class InsuranceRequestDTO {
   
    private Integer insuranceId;

    private Long userId;
 
    private Long bookingId;  // To be updated after successful payment
 
    private String coverageDetails;
 
    private String coverageType;
 
    private double price;
 
    private String provider;
 
    private String status;  // e.g., "PENDING", "ACTIVE", "CANCELLED"
}
 
 

"PaymentResponseDTO.java"
package com.booking.dto;

import lombok.Data;
/**
 * DTO representing the response after processing a payment.
 * This is sent back to the client or other services with payment result details.
 */
@Data
public class PaymentResponseDTO {
    private Long paymentId;
    private Long userId;
    private Long bookingId;
    private double amount;
    private String status;
    private String paymentMethod;
    private String currency;

}


"TravelPackageDTO.java"
package com.booking.dto;

import java.time.LocalDate;
import java.util.List;

import lombok.Data;
/**
 * DTO for transferring complete travel package data across services.
 */
@Data
public class TravelPackageDTO {
	private Long packageId;
	private Long agentId;
	private String title;
	private String description;
	private int duration;
	private double price;
	private int maxCapacity;
	private LocalDate tripStartDate;
	private LocalDate tripEndDate;
	private List<String> highlights;
	private List<FlightDTO> flights;
	private List<HotelDTO> hotels;
	private List<SightseeingDTO> sightseeing;
	private List<ItineraryDTO> itinerary;
	private String imageUrl; //for images in front-end
	private OfferDTO offer;
	
	//newly added fields
	private String country;
	private String destination;
	private String tripType;
	

}


"UserDTO"
package com.booking.dto;

import lombok.Data;
/**
 * DTO for transferring user-related data across services.
 */
@Data
public class UserDTO {
	
	private Long id;
	private String name;
	private String email;
	private String role;

}


"Booking.java"
package com.booking.entity;

import java.time.LocalDate;
import lombok.Data;
import jakarta.persistence.*;

/**
 * Entity class representing a Booking.
 * This class maps to the booking table in the database and contains details about a booking.
 */
@Data
@Entity
public class Booking {
    /**The ID of the booking.*/
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long bookingId;

    /** The ID of the user who made the booking.*/
    private Long userId;

    /**The ID of the travel package associated with the booking.*/
    private Long packageId;

    /**The start date of the trip.*/
    @Column(name = "trip_start_date")
    private LocalDate tripStartDate;

    /**The end date of the trip.*/
    @Column(name = "trip_end_date")
    private LocalDate tripEndDate;

    /**The status of the booking.*/
    private String status;

    /**The ID of the payment associated with the booking.*/
    private Long paymentId;

    /**The ID of the insurance associated with the booking.*/
    private Integer insuranceId;
}

"Payment"
package com.booking.entity;

import lombok.Data;
import jakarta.persistence.*;

/**
 * Entity class representing a Payment.
 * This class maps to the payment table in the database and contains details about a payment.
 */
@Data
@Entity
public class Payment {
    /**The ID of the payment.*/
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long paymentId;

    /**The ID of the user who made the payment.*/
    private Long userId;

    /**The ID of the booking associated with the payment.*/
    private Long bookingId;

    /**The amount of the payment.*/
    private double amount;

    /**The status of the payment.*/
    private String status;

    /**The method of payment, which should be "Credit Card" or "Debit Card".*/
    @Column(nullable = false)
    private String paymentMethod;

    /**The currency of the payment.*/
    private String currency;

    /**The card number used for the payment. This field is not stored in the database.*/
    @Transient
    private String cardNumber;

    /**The CVV code of the card used for the payment. This field is not stored in the database.*/
    @Transient
    private String cvv;

    /**The ATM PIN of the card used for the payment. This field is not stored in the database.*/
    @Transient
    private String atmPin;

    /**The expiry date of the card used for the payment. This field is not stored in the database.*/
    @Transient
    private String expiryDate;
}

"CustomBusinessException.java"
package com.booking.exception;

/**
 * Custom exception used to indicate business rule violations or validation failures
 * that should result in a 400 Bad Request error.
 */
public class CustomBusinessException extends RuntimeException {

    public CustomBusinessException(String message) {
        super(message);
    }

    public CustomBusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}


"GlobalExceptionHandler.java"
package com.booking.exception;

import java.util.Map;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import feign.FeignException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Global exception handler for the application.
 * 
 * This class handles various exceptions that may occur during the execution of the application
 * and provides appropriate responses.
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    /**
     * Handle custom business exceptions.
     * 
     * @param ex The CustomBusinessException instance.
     * @return ResponseEntity containing the error details and HTTP status.
     */
    @ExceptionHandler(CustomBusinessException.class)
    public ResponseEntity<?> handleBusinessError(CustomBusinessException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(Map.of("success", false, "message", ex.getMessage()));
    }

    /**
     * Handle Feign client exceptions.
     * 
     * @param ex The FeignException instance.
     * @return ResponseEntity containing the error details and HTTP status.
     */
    @ExceptionHandler(FeignException.class)
    public ResponseEntity<?> handleFeignError(FeignException ex) {
        return ResponseEntity.status(ex.status())
                .body(Map.of("success", false, "message", "Feign call failed", "details", ex.getMessage()));
    }

    /**
     * Handle general exceptions.
     * 
     * @param ex The Exception instance.
     * @return ResponseEntity containing the error details and HTTP status.
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGeneralError(Exception ex) {
        log.error("Unhandled error: ", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("success", false, "message", "Unexpected error occurred", "details", ex.getMessage()));
    }
}


"Bookingrepoistory.java"
package com.booking.repository;

import com.booking.entity.Booking;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

/**
 * Repository interface for Booking entities.
 * This interface provides methods for performing CRUD operations on Booking entities.
 */
public interface BookingRepository extends JpaRepository<Booking, Long> {

    /**
     * Find bookings by user ID.
     * 
     * @param userId The ID of the user.
     * @return A list of bookings associated with the user ID.
     */
    List<Booking> findByUserId(Long userId);

    /**
     * Count the number of bookings by user ID.
     * 
     * @param userId The ID of the user.
     * @return The number of bookings associated with the user ID.
     */
    int countByUserId(Long userId);

    /**
     * Find bookings by package ID.
     * 
     * @param packageId The ID of the travel package.
     * @return A list of bookings associated with the package ID.
     */
    List<Booking> findByPackageId(Long packageId);
}
 

"PaymentRepository.java"
package com.booking.repository;

import com.booking.entity.Payment;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;

/**
 * Repository interface for Payment entities.
 * This interface provides methods for performing CRUD operations on Payment entities.
 */
public interface PaymentRepository extends JpaRepository<Payment, Long> {

    /**
     * Find a payment by booking ID and user ID.
     * 
     * @param bookingId The ID of the booking.
     * @param userId The ID of the user.
     * @return An Optional containing the payment associated with the booking ID and user ID.
     */
    Optional<Payment> findByBookingIdAndUserId(Long bookingId, Long userId);
}


"ApiResponse.java"
package com.booking.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Class representing a standard API response.
 * This class is used to encapsulate the response data, success status, and message for API endpoints.
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ApiResponse {
	
    /**Indicates whether the API call was successful.*/
    private boolean success;

    /**The message associated with the API response.*/
    private String message;

    /**The data returned by the API call.*/
    private Object data;

}


"BookingService.java"
package com.booking.service;

import com.booking.client.TravelPackageClient;
import com.booking.client.TravelInsuranceClient;
import com.booking.client.UserClient;
import com.booking.dto.BookingDTO;
import com.booking.dto.TravelPackageDTO;
import com.booking.dto.UserDTO;
import com.booking.entity.Booking;
import com.booking.repository.BookingRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import java.time.LocalDate;
import java.util.List;
import java.util.logging.Logger;

/**
 * Service class for handling booking-related operations.
 * 
 * This class provides methods for creating, retrieving, updating, and deleting bookings.
 */
@Service
public class BookingService {

    @Autowired
    private BookingRepository bookingRepo;

    @Autowired
    private TravelPackageClient travelPackageClient;

    @Autowired
    private TravelInsuranceClient travelInsuranceClient;

    @Autowired
    private UserClient userClient;

    private static final Logger logger = Logger.getLogger(BookingService.class.getName());

    /**
     * Create a new booking.
     * 
     * @param bookingRequest The booking entity to be created.
     * @return BookingDTO containing the details of the created booking.
     */
    public BookingDTO createBooking(Booking bookingRequest) {
        Long userId = bookingRequest.getUserId();
        Long packageId = bookingRequest.getPackageId();
        Integer insuranceId = bookingRequest.getInsuranceId();

        logger.info("Creating booking for userId: " + userId + " and packageId: " + packageId);

        // Validate User
        UserDTO user = userClient.getCustomerById(userId);
        if (user == null || !"CUSTOMER".equalsIgnoreCase(user.getRole())) {
            throw new RuntimeException("User is not a valid CUSTOMER.");
        }

        // Validate Package
        TravelPackageDTO travelPackage = travelPackageClient.getPackageById(packageId);
        if (travelPackage == null) {
            throw new IllegalArgumentException("Invalid travel package ID.");
        }

        // Optional: Validate Insurance if selected
        if (insuranceId != null && insuranceId > 0) {
            boolean exists = travelInsuranceClient.validateInsurance(insuranceId);
            if (!exists) {
                throw new IllegalArgumentException("Selected Insurance ID is invalid.");
            }
        }

        // Create and save booking
        Booking booking = new Booking();
        booking.setUserId(userId);
        booking.setPackageId(packageId);
        booking.setInsuranceId(insuranceId);
        booking.setTripStartDate(travelPackage.getTripStartDate());
        booking.setTripEndDate(travelPackage.getTripEndDate());
        booking.setStatus("PENDING");
        Booking savedBooking = bookingRepo.save(booking);

        // Build response DTO
        BookingDTO dto = new BookingDTO();
        dto.setBookingId(savedBooking.getBookingId());
        dto.setUserId(userId);
        dto.setPackageId(packageId);
        dto.setInsuranceId(insuranceId);
        dto.setTripStartDate(savedBooking.getTripStartDate());
        dto.setTripEndDate(savedBooking.getTripEndDate());
        dto.setStatus(savedBooking.getStatus());
        dto.setPaymentId(savedBooking.getPaymentId());

        logger.info("Booking created successfully with bookingId: " + savedBooking.getBookingId());
        return dto;
    }

    /**
     * Retrieve all bookings.
     * 
     * @return A list of all bookings.
     */
    public List<Booking> getAllBookings() {
        return bookingRepo.findAll();
    }

    /**
     * Retrieve a booking by its ID.
     * 
     * @param id The ID of the booking to be retrieved.
     * @return The booking entity.
     */
    public Booking getBookingById(Long id) {
        return bookingRepo.findById(id).orElse(null);
    }

    /**
     * Retrieve a booking by its ID for internal use.
     * 
     * @param id The ID of the booking to be retrieved.
     * @return The booking entity.
     */
    public Booking getInternalBookingById(Long id) {
        return bookingRepo.findById(id).orElse(null);
    }

    /**
     * Delete a booking by its ID.
     * 
     * @param id The ID of the booking to be deleted.
     */
    public void deleteBooking(Long id) {
        bookingRepo.deleteById(id);
    }

    /**
     * Cancel a booking by its ID.
     * 
     * @param bookingId The ID of the booking to be canceled.
     * @return ResponseEntity containing the cancellation status and HTTP status.
     */
    public ResponseEntity<String> cancelBooking(Long bookingId) {
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) {
            return ResponseEntity.badRequest().body("Booking not found.");
        }
        LocalDate today = LocalDate.now();
        if (booking.getTripStartDate().minusDays(7).isBefore(today)) {
            return ResponseEntity.badRequest().body("Cancellation not allowed. Must cancel at least 7 days before departure.");
        }
        booking.setStatus("CANCELLED");
        bookingRepo.save(booking);
        return ResponseEntity.ok("Booking cancelled successfully.");
    }

    /**
     * Retrieve bookings by user ID.
     * 
     * @param userId The ID of the user whose bookings are to be retrieved.
     * @return A list of bookings associated with the user ID.
     */
    public List<Booking> getBookingsByUserId(Long userId) {
        return bookingRepo.findByUserId(userId);
    }

    /**
     * Check if a user has completed a package.
     * 
     * @param userId The ID of the user.
     * @param packageId The ID of the package.
     * @return boolean indicating whether the user has completed the package.
     */
    public boolean hasUserCompletedPackage(Long userId, String packageId) {
        List<Booking> bookings = bookingRepo.findByUserId(userId);
        LocalDate today = LocalDate.now();
        return bookings.stream()
            .anyMatch(b ->
                String.valueOf(b.getPackageId()).equals(packageId) &&
                "CONFIRMED".equalsIgnoreCase(b.getStatus()) &&
                !b.getTripEndDate().isAfter(today) // includes today
            );
    }

    /**
     * Retrieve all travel packages.
     * 
     * @return A list of TravelPackageDTO representing all travel packages.
     */
    public List<TravelPackageDTO> getAllPackages() {
        return travelPackageClient.getAllPackages();
    }

    /**
     * Retrieve a travel package by its ID.
     * 
     * @param packageId The ID of the travel package to be retrieved.
     * @return The TravelPackageDTO representing the travel package.
     */
    public TravelPackageDTO getPackageById(Long packageId) {
        return travelPackageClient.getPackageById(packageId);
    }
}

"NotificationService.java"
package com.booking.service;

import com.booking.entity.Booking;
import com.booking.entity.Payment;
import com.booking.dto.UserDTO;
import com.booking.client.TravelPackageClient;
import com.booking.client.UserClient;
import com.booking.dto.TravelPackageDTO;
import com.booking.exception.CustomBusinessException;
import feign.FeignException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Service class for handling notification-related operations.
 * This class provides methods for sending booking details to customers and travel agents via email.
 */
@Service
public class NotificationService {

    @Autowired
    private JavaMailSender mailSender;

    @Autowired
    private UserClient userClient;

    @Autowired
    private TravelPackageClient travelPackageClient;

    private static final Logger log = LoggerFactory.getLogger(NotificationService.class);

    private final String senderEmail = "indhaanman@gmail.com";

    /**
     * Send booking details to the customer via email.
     * 
     * @param booking The booking entity containing the booking details.
     * @param payment The payment entity containing the payment details.
     */
    public void notifyCustomer(Booking booking, Payment payment) {
        UserDTO user = userClient.getCustomerById(booking.getUserId());
        String customerEmail = user.getEmail();

        String subject = "Your Travel Booking is Confirmed – Booking ID: " + booking.getBookingId();
        String body = "Dear Customer,\n\n"
                + "Thank you for booking your travel with us!\n\n"
                + "Your booking has been successfully confirmed. Here are the details:\n\n"
                + "- Booking ID: " + booking.getBookingId() + "\n"
                + "- Package ID: " + booking.getPackageId() + "\n"
                + "- Travel Dates: " + booking.getTripStartDate() + " to " + booking.getTripEndDate() + "\n"
                + "- Payment Amount: " + payment.getAmount() + " " + payment.getCurrency() + "\n"
                + "- Payment Status: " + payment.getStatus() + "\n\n"
                + "We look forward to providing you with a wonderful travel experience.\n\n"
                + "Warm regards,\nTravel Booking Team";

        sendEmail(customerEmail, subject, body);
        System.out.println("Email is sent to " + customerEmail);
    }

    /**
     * Send booking details to the travel agent via email.
     * 
     * @param booking The booking entity containing the booking details.
     * @param payment The payment entity containing the payment details.
     */
    public void notifyTravelAgent(Booking booking, Payment payment) {
        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());

        try {
            String agentEmail = userClient.getCustomerById(pkg.getAgentId()).getEmail();
        } catch (FeignException.Forbidden e) {
            log.error("Forbidden from UserService: {}", e.getMessage());
            throw new CustomBusinessException("User is not a CUSTOMER");
        }
        String agentEmail = userClient.getCustomerById(pkg.getAgentId()).getEmail();

        String subject = "New Booking Received – Booking ID: " + booking.getBookingId();
        String body = "Dear Travel Agent,\n\n"
                + "A new booking has been successfully made. Please find the details below:\n\n"
                + "- Booking ID: " + booking.getBookingId() + "\n"
                + "- Customer ID: " + booking.getUserId() + "\n"
                + "- Package ID: " + booking.getPackageId() + "\n"
                + "- Travel Dates: " + booking.getTripStartDate() + " to " + booking.getTripEndDate() + "\n"
                + "- Payment Amount: " + payment.getAmount() + " " + payment.getCurrency() + "\n"
                + "- Payment Status: " + payment.getStatus() + "\n\n"
                + "Please ensure all arrangements are in place for the customer's travel.\n\n"
                + "Best regards,\nTravel Booking System";

        sendEmail(agentEmail, subject, body);
        System.out.println("Email is sent to " + agentEmail);
    }

    /**
     * Send an email with the specified subject and body to the specified recipient.
     * 
     * @param to The recipient's email address.
     * @param subject The subject of the email.
     * @param body The body of the email.
     */
    private void sendEmail(String to, String subject, String body) {
        SimpleMailMessage mail = new SimpleMailMessage();
        mail.setFrom(senderEmail);
        mail.setTo(to);
        mail.setSubject(subject);
        mail.setText(body);
        mailSender.send(mail);
    }
}


"PaymentService.java"
package com.booking.service;

import com.booking.client.TravelPackageClient;
import com.booking.client.TravelInsuranceClient;
import com.booking.dto.OfferDTO;
import com.booking.dto.TravelPackageDTO;
import com.booking.entity.Booking;
import com.booking.entity.Payment;
import com.booking.exception.CustomBusinessException;
import com.booking.repository.BookingRepository;
import com.booking.repository.PaymentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

/**
 * Service class for handling payment-related operations.
 * This class provides methods for processing payments, calculating expected totals,
 * and retrieving payment details.
 */
@Service
public class PaymentService {

    @Autowired
    private PaymentRepository paymentRepo;

    @Autowired
    private BookingRepository bookingRepo;

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private TravelPackageClient travelPackageClient;

    @Autowired
    private TravelInsuranceClient travelInsuranceClient;

    private static final Logger log = LoggerFactory.getLogger(PaymentService.class);

    /**
     * Process a payment with an optional coupon code.
     * 
     * @param payment The payment entity to be processed.
     * @param couponCodeApplied The optional coupon code for discount.
     * @return The processed Payment entity.
     */
    public Payment processPayment(Payment payment, String couponCodeApplied) {
        Optional<Payment> existingPayment = paymentRepo.findByBookingIdAndUserId(payment.getBookingId(), payment.getUserId());

        if (existingPayment.isPresent()) {
            throw new CustomBusinessException("Payment already made for this booking by this user.");
        }

        Long bookingId = payment.getBookingId();
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) {
            throw new IllegalArgumentException("Booking with ID " + bookingId + " not found.");
        }

        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) {
            throw new IllegalArgumentException("Invalid package ID associated with booking.");
        }

        double packagePrice = pkg.getPrice();
        double insurancePrice = 0.0;
        if (booking.getInsuranceId() != null && booking.getInsuranceId() > 0) {
            try {
                insurancePrice = travelInsuranceClient.getInsurancePriceByInsuranceId(booking.getInsuranceId().intValue());
            } catch (Exception e) {
                throw new IllegalArgumentException("Failed to fetch insurance price. Verify Insurance Service is reachable.");
            }
        }

        double discountAmount = 0.0;
        if (couponCodeApplied != null && pkg.getOffer() != null) {
            OfferDTO offer = pkg.getOffer();
            if (couponCodeApplied.equalsIgnoreCase(offer.getCouponCode()) && offer.isActive()) {
                discountAmount = (packagePrice * offer.getDiscountPercentage()) / 100.0;
                System.out.println("Coupon applied. Discount amount: " + discountAmount);
            }
        }

        double expectedTotal = packagePrice + insurancePrice - discountAmount;

        if (Math.abs(payment.getAmount() - expectedTotal) > 0.01) {
            log.warn("Payment mismatch: paid={}, expected={}", payment, expectedTotal);
            throw new IllegalArgumentException("Payment amount mismatch. Expected: " + expectedTotal);
        }

        if (!payment.getPaymentMethod().equalsIgnoreCase("Credit Card") &&
            !payment.getPaymentMethod().equalsIgnoreCase("Debit Card")) {
            throw new IllegalArgumentException("Only Credit Card or Debit Card accepted.");
        }

        if (payment.getCardNumber() == null || !payment.getCardNumber().matches("\\d{16}")) {
            throw new IllegalArgumentException("Invalid card number.");
        }

        if (payment.getCvv() == null || !payment.getCvv().matches("\\d{3}")) {
            throw new IllegalArgumentException("Invalid CVV.");
        }

        if (payment.getAtmPin() == null || !payment.getAtmPin().matches("\\d{4}")) {
            throw new IllegalArgumentException("Invalid ATM PIN.");
        }

        if (payment.getExpiryDate() == null || !payment.getExpiryDate().matches("\\d{2}/\\d{2}")) {
            throw new IllegalArgumentException("Expiry date format invalid.");
        }

        String[] parts = payment.getExpiryDate().split("/");
        int expMonth = Integer.parseInt(parts[0]);
        int expYear = 2000 + Integer.parseInt(parts[1]);

        int currentMonth = LocalDate.now().getMonthValue();
        int currentYear = LocalDate.now().getYear();

        if (expMonth < 1 || expMonth > 12 || expYear < currentYear ||
           (expYear == currentYear && expMonth < currentMonth)) {
            throw new IllegalArgumentException("Card has expired.");
        }

        payment.setStatus("PAID");
        Payment savedPayment = paymentRepo.save(payment);

        booking.setStatus("CONFIRMED");
        booking.setPaymentId(savedPayment.getPaymentId());
        bookingRepo.save(booking);

        if (insurancePrice > 0.0) {
            travelInsuranceClient.updateInsuranceBookingId(booking.getInsuranceId().intValue(), booking.getBookingId());
        }

        notificationService.notifyCustomer(booking, savedPayment);
        notificationService.notifyTravelAgent(booking, savedPayment);

        return savedPayment;
    }

    /**
     * Calculate the total payable amount before actual payment.
     * 
     * @param bookingId The ID of the booking.
     * @param couponCodeApplied The optional coupon code for discount.
     * @return The total payable amount.
     */
    public double calculateExpectedTotal(Long bookingId, String couponCodeApplied) {
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) throw new IllegalArgumentException("Booking not found");

        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) throw new IllegalArgumentException("Package not found");

        double packagePrice = pkg.getPrice();

        double insurancePrice = 0.0;
        if (booking.getInsuranceId() != null && booking.getInsuranceId() > 0) {
            insurancePrice = travelInsuranceClient.getInsurancePriceByInsuranceId(booking.getInsuranceId().intValue());
        }

        double discountAmount = 0.0;
        if (couponCodeApplied != null && pkg.getOffer() != null) {
            OfferDTO offer = pkg.getOffer();
            if (couponCodeApplied.equalsIgnoreCase(offer.getCouponCode()) && offer.isActive()) {
                discountAmount = (packagePrice * offer.getDiscountPercentage()) / 100.0;
            }
        }

        return packagePrice + insurancePrice - discountAmount;
    }

    /**
     * Retrieve all payments.
     * 
     * @return A list of all payments.
     */
    public List<Payment> getAllPayments() {
        return paymentRepo.findAll();
    }

    /**
     * Retrieve a payment by its ID.
     * 
     * @param id The ID of the payment to be retrieved.
     * @return The payment entity.
     */
    public Payment getPaymentById(Long id) {
        return paymentRepo.findById(id).orElse(null);
    }
}

"application properties"
spring.application.name=TravelBooking-PaymentModule
spring.datasource.url=jdbc:mysql://localhost:3306/booking_db
server.port=8086
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
logging.level.org.hibernate.SQL=debug
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=indhaanman@gmail.com
spring.mail.password=ibzbwveckpfjibey
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

spring.cloud.compatibility-verifier.enabled=false

# optional:Srt timeout and logging
spring.cloud.openfeign.client.config.default.connectTimeout=5000
spring.cloud.openfeign.client.config.default.readTimeout=5000


spring.cloud.openfeign.client.config.default.loggerLevel=full


# Eureka Client Configuration
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
eureka.instance.prefer-ip-address=true


#debug=true
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true

logging.level.root=DEBUG
logging.level.org.springframework.web=DEBUG

"pom.xml"
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
 
    <modelVersion>4.0.0</modelVersion>
 
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
 
    <groupId>com.booking</groupId>
    <artifactId>TravelBooking_PaymentModule</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>TravelBooking_PaymentModule</name>
    <properties>
        <java.version>17</java.version>
    </properties>
 
    <!-- Spring Cloud BOM -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>2024.0.1</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
 
    <dependencies>
        <!-- Spring Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!--Eureka Client Dependency-->
        <dependency>
    		<groupId>org.springframework.cloud</groupId>
    		<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>    
		</dependency>
 
 
        <!-- Thymeleaf (optional) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
		<dependency>
    	<groupId>org.projectlombok</groupId>
    	<artifactId>lombok</artifactId>
    	<version>1.18.30</version> <!-- Use the latest version if needed -->
    	<scope>provided</scope>
		</dependency>
 
        <!-- Spring Data JPA -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
 
        <!-- MySQL Connector -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.33</version>
        </dependency>
 
        <!-- Spring Cloud OpenFeign -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <!--Dependency for load balancing-->
        <dependency>
   			<groupId>org.springframework.cloud</groupId>
    		<artifactId>spring-cloud-starter-loadbalancer</artifactId>
		</dependency>
 
 
        <!-- Spring Mail -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
 
        <!-- Web Services (optional) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web-services</artifactId>
        </dependency>
 
        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
       
       <!--<dependency>
        	<groupId>com.example.apigateway</groupId>
        	<artifactId>usermanagement-service</artifactId>
        	<version>0.0.1-SNAPSHOT</version>
        </dependency>-->
    </dependencies>
 
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
 
</project>


"webconfig.java"
package com.booking.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                        .allowedOrigins("http://localhost:4200") // ✅ only one origin!
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                        .allowedHeaders("*")
                        .allowCredentials(true);
            }
        };
    }
}

///////////
access-control-allow-credentials
true
access-control-allow-credentials
true
access-control-allow-origin
http://localhost:4200
access-control-allow-origin
http://localhost:4200
content-type
application/json
date
Mon, 30 Jun 2025 17:35:15 GMT
transfer-encoding
chunked
vary
Origin
vary
Access-Control-Request-Method
vary
Access-Control-Request-Headers
vary
Origin
vary
Access-Control-Request-Method
vary
Access-Control-Request-Headers
accept
application/json, text/plain, */*
accept-encoding
gzip, deflate, br, zstd
accept-language
en-US,en;q=0.9
authorization
Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJQYW1hbmppLkt1bWFyQGNvZ25pemFudC5jb20iLCJyb2xlIjoiQ1VTVE9NRVIiLCJpYXQiOjE3NTEzMDMxNjMsImV4cCI6MTc1MTMwNjc2M30.DLUUPAARodN582FKZmsUQMTBJLvfC-pNTbxqQNNXSuM
cache-control
no-cache
connection
keep-alive
content-length
101
content-type
application/json
host
localhost:8080
origin
http://localhost:4200
pragma
no-cache
referer
http://localhost:4200/
sec-ch-ua
"Google Chrome";v="137", "Chromium";v="137", "Not/A)Brand";v="24"
sec-ch-ua-mobile
?0
sec-ch-ua-platform
"Windows"
sec-fetch-dest
empty
sec-fetch-mode
cors
sec-fetch-site
same-site
user-agent
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36


///////////
@PostMapping
public ResponseEntity<?> createBooking(@RequestBody Booking booking) {
    try {
        BookingDTO bookingDTO = service.createBooking(booking);
        return new ResponseEntity<>(bookingDTO, HttpStatus.CREATED);
    } catch (RuntimeException ex) {
        ex.printStackTrace(); // ✅ shows full error in backend logs
        logger.severe("Error creating booking: " + ex.getMessage());

        // ✅ return a proper error JSON message to frontend
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                             .body(new ApiResponse(false, "Booking failed: " + ex.getMessage(), null));
    }
}

.\///////\\/\/
public BookingDTO createBooking(Booking bookingRequest) {
    Long userId = bookingRequest.getUserId();
    Long packageId = bookingRequest.getPackageId();
    Integer insuranceId = bookingRequest.getInsuranceId();

    logger.info("Creating booking for userId: " + userId + " and packageId: " + packageId);

    // 1. Validate User
    UserDTO user;
    try {
        user = userClient.getCustomerById(userId);
        if (user == null || !"CUSTOMER".equalsIgnoreCase(user.getRole())) {
            throw new RuntimeException("User is not a valid CUSTOMER.");
        }
    } catch (Exception ex) {
        ex.printStackTrace();
        throw new RuntimeException("Failed to fetch user details: " + ex.getMessage());
    }

    // 2. Validate Package
    TravelPackageDTO travelPackage;
    try {
        travelPackage = travelPackageClient.getPackageById(packageId);
        if (travelPackage == null) {
            throw new IllegalArgumentException("Invalid travel package ID.");
        }
    } catch (Exception ex) {
        ex.printStackTrace();
        throw new RuntimeException("Failed to fetch package details: " + ex.getMessage());
    }

    // 3. Validate Insurance (optional)
    if (insuranceId != null && insuranceId > 0) {
        try {
            boolean exists = travelInsuranceClient.validateInsurance(insuranceId);
            if (!exists) {
                throw new IllegalArgumentException("Selected Insurance ID is invalid.");
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            throw new RuntimeException("Failed to validate insurance: " + ex.getMessage());
        }
    }

    // 4. Create and save booking
    Booking booking = new Booking();
    booking.setUserId(userId);
    booking.setPackageId(packageId);
    booking.setInsuranceId(insuranceId);
    booking.setTripStartDate(travelPackage.getTripStartDate());
    booking.setTripEndDate(travelPackage.getTripEndDate());
    booking.setStatus("PENDING");

    Booking savedBooking = bookingRepo.save(booking);

    // 5. Build response DTO
    BookingDTO dto = new BookingDTO();
    dto.setBookingId(savedBooking.getBookingId());
    dto.setUserId(userId);
    dto.setPackageId(packageId);
    dto.setInsuranceId(insuranceId);
    dto.setTripStartDate(savedBooking.getTripStartDate());
    dto.setTripEndDate(savedBooking.getTripEndDate());
    dto.setStatus(savedBooking.getStatus());
    dto.setPaymentId(savedBooking.getPaymentId());

    logger.info("Booking created successfully with bookingId: " + savedBooking.getBookingId());
    return dto;
}
