"Payment Conctroller"
package com.booking.controller;

import com.booking.dto.PaymentResponseDTO;
import com.booking.entity.Payment;
import com.booking.service.PaymentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/payments")
public class PaymentController {

    @Autowired private PaymentService paymentService;

    @PostMapping public PaymentResponseDTO process(@RequestBody Payment payment) {
        Payment savedPayment = paymentService.processPayment(payment);
        PaymentResponseDTO response = new PaymentResponseDTO();
        response.setPaymentId(savedPayment.getPaymentId());
        response.setUserId(savedPayment.getUserId());
        response.setBookingId(savedPayment.getBookingId());
        response.setAmount(savedPayment.getAmount());
        response.setStatus(savedPayment.getStatus());
        response.setPaymentMethod(savedPayment.getPaymentMethod());
        response.setCurrency(savedPayment.getCurrency());
        return response;
    }

    @GetMapping public List<Payment> getAll() { return paymentService.getAllPayments(); }
    @GetMapping("/{id}") public Payment getById(@PathVariable Long id) { return paymentService.getPaymentById(id); }
}


"PaymentResponseDTO"
package com.booking.dto;

public class PaymentResponseDTO {
    private Long paymentId;
    private Long userId;
    private Long bookingId;
    private double amount;
    private String status;
    private String paymentMethod;
    private String currency;

    // Getters and Setters
    public Long getPaymentId() {
        return paymentId;
    }

    public void setPaymentId(Long paymentId) {
        this.paymentId = paymentId;
    }

    public Long getUserId() {
        return userId;
    }

    public void setUserId(Long userId) {
        this.userId = userId;
    }

    public Long getBookingId() {
        return bookingId;
    }

    public void setBookingId(Long bookingId) {
        this.bookingId = bookingId;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public String getCurrency() {
        return currency;
    }

    public void setCurrency(String currency) {
        this.currency = currency;
    }
}


"Payment.java"(Entity)
package com.booking.entity;

import jakarta.persistence.*;

@Entity
public class Payment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long paymentId;
	private Long userId;
    private Long bookingId;
    private double amount;
    private String status;
    
    @Column(nullable = false)
    private String paymentMethod; // Should be "Credit Card" or "Debit Card"
 
    private String currency;
 
    @Transient
    private String cardNumber;  // Not stored in DB
 
    @Transient
    private String cvv;			// Not stored in DB
 
    @Transient
    private String atmPin;		// Not stored in DB
    
    @Transient
    private String expiryDate;	// Not stored in DB
    
    // Getters and Setters
    
	public Long getUserId() {
		return userId;
	}
	public void setUserId(Long userId) {
		this.userId = userId;
	}
	public Long getBookingId() {
		return bookingId;
	}
	public void setBookingId(Long bookingId) {
		this.bookingId = bookingId;
	}
	public double getAmount() {
		return amount;
	}
	public void setAmount(double amount) {
		this.amount = amount;
	}
	public String getStatus() {
		return status;
	}
	public void setStatus(String status) {
		this.status = status;
	}
	public String getPaymentMethod() {
		return paymentMethod;
	}
	public void setPaymentMethod(String paymentMethod) {
		this.paymentMethod = paymentMethod;
	}
	public String getCurrency() {
		return currency;
	}
	public void setCurrency(String currency) {
		this.currency = currency;
	}
	public String getCardNumber() {
		return cardNumber;
	}
	public void setCardNumber(String cardNumber) {
		this.cardNumber = cardNumber;
	}
	public String getCvv() {
		return cvv;
	}
	public void setCvv(String cvv) {
		this.cvv = cvv;
	}
	public String getAtmPin() {
		return atmPin;
	}
	public void setAtmPin(String atmPin) {
		this.atmPin = atmPin;
	}
	public Long getPaymentId() {
		return paymentId;
	}
	public void setPaymentId(Long paymentId) {
		this.paymentId = paymentId;
	}
	public String getExpiryDate() {
		return expiryDate;
	}
	public void setExpiryDate(String expiryDate) {
		this.expiryDate = expiryDate;
	}
}

"PaymentRepository"
package com.booking.repository;
 
import com.booking.entity.Payment;
import org.springframework.data.jpa.repository.JpaRepository;
 
public interface PaymentRepository extends JpaRepository<Payment, Long> {

}


"PaymentService"
package com.booking.service;

import com.booking.client.TravelPackageClient;
import com.booking.dto.TravelPackageDTO;
import com.booking.entity.Booking;
import com.booking.entity.Payment;
import com.booking.repository.BookingRepository;
import com.booking.repository.PaymentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

@Service
public class PaymentService {

    @Autowired
    private PaymentRepository paymentRepo;

    @Autowired
    private BookingRepository bookingRepo;

    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private TravelPackageClient travelPackageClient;

    public Payment processPayment(Payment payment) {
        if (!payment.getPaymentMethod().equalsIgnoreCase("Credit Card") &&
            !payment.getPaymentMethod().equalsIgnoreCase("Debit Card")) {
            throw new IllegalArgumentException("Only Credit Card or Debit Card are accepted.");
        }

        if (payment.getCardNumber() == null || !payment.getCardNumber().matches("\\d{16}")) {
            throw new IllegalArgumentException("Invalid card number. Must be 16 digits.");
        }

        if (payment.getCvv() == null || !payment.getCvv().matches("\\d{3}")) {
            throw new IllegalArgumentException("Invalid CVV. Must be 3 digits.");
        }

        if (payment.getAtmPin() == null || !payment.getAtmPin().matches("\\d{4}")) {
            throw new IllegalArgumentException("Invalid ATM PIN. Must be 4 digits.");
        }

        // Expiry Date Format: MM/YY
        if (payment.getExpiryDate() == null || !payment.getExpiryDate().matches("\\d{2}/\\d{2}")) {
            throw new IllegalArgumentException("Expiry date must be in MM/YY format.");
        }

        String[] parts = payment.getExpiryDate().split("/");
        int expMonth = Integer.parseInt(parts[0]);
        int expYear = 2000 + Integer.parseInt(parts[1]); // e.g., "25" becomes 2025

        if (expMonth < 1 || expMonth > 12) {
            throw new IllegalArgumentException("Expiry month must be between 01 and 12.");
        }

        int currentMonth = LocalDate.now().getMonthValue();
        int currentYear = LocalDate.now().getYear();

        if (expYear < currentYear || (expYear == currentYear && expMonth < currentMonth)) {
            throw new IllegalArgumentException("Card has expired.");
        }

        payment.setStatus("PAID");
        Payment savedPayment = paymentRepo.save(payment);

        // Fetch booking details using bookingId
        Long bookingId = payment.getBookingId();
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        
        if (booking != null) {
        	TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        	if(payment.getAmount() != pkg.getPrice()) {
        		throw new IllegalArgumentException("Amount does not match package price.");
        	}
        	
        	notificationService.notifyCustomer(booking, savedPayment);
            notificationService.notifyTravelAgent(booking, savedPayment);
            
        }

        return savedPayment;
    }

    public List<Payment> getAllPayments() {
        return paymentRepo.findAll();
    }

    public Payment getPaymentById(Long id) {
        return paymentRepo.findById(id).orElse(null);
    }
}

"Notification Service"
package com.booking.service;

import com.booking.entity.Booking;
import com.booking.entity.Payment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
public class NotificationService {

    @Autowired
    private JavaMailSender mailSender;
    private final String senderEmail = "indhaanman@gmail.com";
    private final String customerEmail = "snehithkumar535@gmail.com";
    private final String agentEmail = "padmajareddy630@gmail.com";

    //Booking details are sent to customers through Email
    public void notifyCustomer(Booking booking, Payment payment) {
        String subject = "Your Travel Booking is Confirmed – Booking ID: " + booking.getBookingId();
        String body = "Dear Customer,\n\n"
                + "Thank you for booking your travel with us!\n\n"
                + "Your booking has been successfully confirmed. Here are the details:\n\n"
                + "- Booking ID: " + booking.getBookingId() + "\n"
                + "- Package ID: " + booking.getPackageId() + "\n"
                + "- Travel Dates: " + booking.getTripStartDate() + " to " + booking.getTripEndDate() + "\n"
                + "- Payment Amount: " + payment.getAmount() + " "+ payment.getCurrency() + "\n"
                + "- Payment Status: " + payment.getStatus() + "\n\n"
                + "We look forward to providing you with a wonderful travel experience.\n\n"
                + "Warm regards,\nTravel Booking Team";

        sendEmail(customerEmail, subject, body);
        System.out.println("Email is sent to " + customerEmail);
    }

    //Booking details are sent to travel agent through Email
    public void notifyTravelAgent(Booking booking, Payment payment) {
        String subject = "New Booking Received – Booking ID: " + booking.getBookingId();
        String body = "Dear Travel Agent,\n\n"
                + "A new booking has been successfully made. Please find the details below:\n\n"
                + "- Booking ID: " + booking.getBookingId() + "\n"
                + "- Customer ID: " + booking.getUserId() + "\n"
                + "- Package ID: " + booking.getPackageId() + "\n"
                + "- Travel Dates: " + booking.getTripStartDate() + " to " + booking.getTripEndDate() + "\n"
                + "- Payment Amount: " + payment.getAmount() + " " + payment.getCurrency() + "\n"
                + "- Payment Status: " + payment.getStatus() + "\n\n"
                + "Please ensure all arrangements are in place for the customer's travel.\n\n"
                + "Best regards,\nTravel Booking System";

        sendEmail(agentEmail, subject, body);
        System.out.println("Email is sent to " + agentEmail);
    }

    private void sendEmail(String to, String subject, String body) {
        SimpleMailMessage mail = new SimpleMailMessage();
        mail.setFrom(senderEmail);
        mail.setTo(to);
        mail.setSubject(subject);
        mail.setText(body);
        mailSender.send(mail);
    }
}


package com.booking.service;

import com.booking.client.TravelPackageClient;
import com.booking.dto.TravelPackageDTO;
import com.booking.entity.Booking;
import com.booking.entity.Payment;
import com.booking.repository.BookingRepository;
import com.booking.repository.PaymentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

@Service
public class PaymentService {

    @Autowired
    private PaymentRepository paymentRepo;

    @Autowired
    private BookingRepository bookingRepo;

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private TravelPackageClient travelPackageClient;

    public Payment processPayment(Payment payment) {
        // 1. Validate Booking
        Long bookingId = payment.getBookingId();
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) {
            throw new IllegalArgumentException("Booking with ID " + bookingId + " not found.");
        }

        // 2. Validate Travel Package
        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) {
            throw new IllegalArgumentException("Invalid package ID associated with booking.");
        }

        // 3. Validate Payment Method and Details
        if (!payment.getPaymentMethod().equalsIgnoreCase("Credit Card") &&
            !payment.getPaymentMethod().equalsIgnoreCase("Debit Card")) {
            throw new IllegalArgumentException("Only Credit Card or Debit Card are accepted.");
        }

        if (payment.getCardNumber() == null || !payment.getCardNumber().matches("\\d{16}")) {
            throw new IllegalArgumentException("Invalid card number. Must be 16 digits.");
        }

        if (payment.getCvv() == null || !payment.getCvv().matches("\\d{3}")) {
            throw new IllegalArgumentException("Invalid CVV. Must be 3 digits.");
        }

        if (payment.getAtmPin() == null || !payment.getAtmPin().matches("\\d{4}")) {
            throw new IllegalArgumentException("Invalid ATM PIN. Must be 4 digits.");
        }

        if (payment.getExpiryDate() == null || !payment.getExpiryDate().matches("\\d{2}/\\d{2}")) {
            throw new IllegalArgumentException("Expiry date must be in MM/YY format.");
        }

        String[] parts = payment.getExpiryDate().split("/");
        int expMonth = Integer.parseInt(parts[0]);
        int expYear = 2000 + Integer.parseInt(parts[1]);

        int currentMonth = LocalDate.now().getMonthValue();
        int currentYear = LocalDate.now().getYear();

        if (expMonth < 1 || expMonth > 12 || expYear < currentYear ||
           (expYear == currentYear && expMonth < currentMonth)) {
            throw new IllegalArgumentException("Card has expired.");
        }

        // 4. Amount Validation
        if (payment.getAmount() != pkg.getPrice()) {
            throw new IllegalArgumentException("Payment amount does not match the package price.");
        }

        // 5. Save Payment and Update Booking
        payment.setStatus("PAID");
        Payment savedPayment = paymentRepo.save(payment);

        booking.setPaymentId(savedPayment.getPaymentId());
        bookingRepo.save(booking);

        // 6. Send Notifications
        notificationService.notifyCustomer(booking, savedPayment);
        notificationService.notifyTravelAgent(booking, savedPayment);

        return savedPayment;
    }

    public List<Payment> getAllPayments() {
        return paymentRepo.findAll();
    }

    public Payment getPaymentById(Long id) {
        return paymentRepo.findById(id).orElse(null);
    }
}


//24/06/25
package com.booking.service;

import com.booking.client.TravelPackageClient;
import com.booking.dto.TravelPackageDTO;
import com.booking.entity.Booking;
import com.booking.entity.Payment;
import com.booking.repository.BookingRepository;
import com.booking.repository.PaymentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

@Service
public class PaymentService {

    @Autowired
    private PaymentRepository paymentRepo;

    @Autowired
    private BookingRepository bookingRepo;

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private TravelPackageClient travelPackageClient;

    public Payment processPayment(Payment payment) {
        // 1. Validate Booking
        Long bookingId = payment.getBookingId();
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) {
            throw new IllegalArgumentException("Booking with ID " + bookingId + " not found.");
        }

        // 2. Validate Travel Package
        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) {
            throw new IllegalArgumentException("Invalid package ID associated with booking.");
        }

        // 3. Validate Payment Method and Details
        if (!payment.getPaymentMethod().equalsIgnoreCase("Credit Card") &&
            !payment.getPaymentMethod().equalsIgnoreCase("Debit Card")) {
            throw new IllegalArgumentException("Only Credit Card or Debit Card are accepted.");
        }

        if (payment.getCardNumber() == null || !payment.getCardNumber().matches("\\d{16}")) {
            throw new IllegalArgumentException("Invalid card number. Must be 16 digits.");
        }

        if (payment.getCvv() == null || !payment.getCvv().matches("\\d{3}")) {
            throw new IllegalArgumentException("Invalid CVV. Must be 3 digits.");
        }

        if (payment.getAtmPin() == null || !payment.getAtmPin().matches("\\d{4}")) {
            throw new IllegalArgumentException("Invalid ATM PIN. Must be 4 digits.");
        }

        if (payment.getExpiryDate() == null || !payment.getExpiryDate().matches("\\d{2}/\\d{2}")) {
            throw new IllegalArgumentException("Expiry date must be in MM/YY format.");
        }

        String[] parts = payment.getExpiryDate().split("/");
        int expMonth = Integer.parseInt(parts[0]);
        int expYear = 2000 + Integer.parseInt(parts[1]);

        int currentMonth = LocalDate.now().getMonthValue();
        int currentYear = LocalDate.now().getYear();

        if (expMonth < 1 || expMonth > 12 || expYear < currentYear ||
           (expYear == currentYear && expMonth < currentMonth)) {
            throw new IllegalArgumentException("Card has expired.");
        }

        // 4. Amount Validation
        if (payment.getAmount() != pkg.getPrice()) {
            throw new IllegalArgumentException("Payment amount does not match the package price.");
        }

        // 5. Save Payment and Update Booking
        payment.setStatus("PAID");
        Payment savedPayment = paymentRepo.save(payment);

        booking.setPaymentId(savedPayment.getPaymentId());
        bookingRepo.save(booking);

        // 6. Send Notifications
        notificationService.notifyCustomer(booking, savedPayment);
        notificationService.notifyTravelAgent(booking, savedPayment);

        return savedPayment;
    }

    public List<Payment> getAllPayments() {
        return paymentRepo.findAll();
    }

    public Payment getPaymentById(Long id) {
        return paymentRepo.findById(id).orElse(null);
    }
}

// 24/06/25
package com.booking.service;

import com.booking.client.TravelPackageClient;
import com.booking.dto.TravelPackageDTO;
import com.booking.dto.InsuranceDTO;
import com.booking.entity.Booking;
import com.booking.entity.Payment;
import com.booking.repository.BookingRepository;
import com.booking.repository.PaymentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

@Service
public class PaymentService {

    @Autowired
    private PaymentRepository paymentRepo;

    @Autowired
    private BookingRepository bookingRepo;

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private TravelPackageClient travelPackageClient;

    public Payment processPayment(Payment payment) {
        // 1. Validate Booking
        Long bookingId = payment.getBookingId();
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) {
            throw new IllegalArgumentException("Booking with ID " + bookingId + " not found.");
        }

        // 2. Validate Travel Package
        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) {
            throw new IllegalArgumentException("Invalid package ID associated with booking.");
        }

        // 3. Validate Payment Method and Details
        if (!payment.getPaymentMethod().equalsIgnoreCase("Credit Card") &&
            !payment.getPaymentMethod().equalsIgnoreCase("Debit Card")) {
            throw new IllegalArgumentException("Only Credit Card or Debit Card are accepted.");
        }

        if (payment.getCardNumber() == null || !payment.getCardNumber().matches("\\d{16}")) {
            throw new IllegalArgumentException("Invalid card number. Must be 16 digits.");
        }

        if (payment.getCvv() == null || !payment.getCvv().matches("\\d{3}")) {
            throw new IllegalArgumentException("Invalid CVV. Must be 3 digits.");
        }

        if (payment.getAtmPin() == null || !payment.getAtmPin().matches("\\d{4}")) {
            throw new IllegalArgumentException("Invalid ATM PIN. Must be 4 digits.");
        }

        if (payment.getExpiryDate() == null || !payment.getExpiryDate().matches("\\d{2}/\\d{2}")) {
            throw new IllegalArgumentException("Expiry date must be in MM/YY format.");
        }

        String[] parts = payment.getExpiryDate().split("/");
        int expMonth = Integer.parseInt(parts[0]);
        int expYear = 2000 + Integer.parseInt(parts[1]);

        int currentMonth = LocalDate.now().getMonthValue();
        int currentYear = LocalDate.now().getYear();

        if (expMonth < 1 || expMonth > 12 || expYear < currentYear ||
           (expYear == currentYear && expMonth < currentMonth)) {
            throw new IllegalArgumentException("Card has expired.");
        }

        // 4. Amount Validation
        double expectedTotal = pkg.getPrice() + insurance.getInsurancePrice(insuranceDTO.getPrice());
        if (payment.getAmount() != expectedTotal) {
            throw new IllegalArgumentException("Payment amount does not match the total price (Package + Insurance).");
        }

        // 5. Save Payment and Update Booking
        payment.setStatus("PAID");
        Payment savedPayment = paymentRepo.save(payment);

        booking.setPaymentId(savedPayment.getPaymentId());
        bookingRepo.save(booking);

        // 6. Send Notifications
        notificationService.notifyCustomer(booking, savedPayment);
        notificationService.notifyTravelAgent(booking, savedPayment);

        return savedPayment;
    }
    
    public List<Payment> getAllPayments() {
        return paymentRepo.findAll();
    }

    public Payment getPaymentById(Long id) {
        return paymentRepo.findById(id).orElse(null);
    }
}


//////////
package com.booking.dto;

import lombok.Data;

@Data
public class OfferDTO {
	private String couponCode;
	private String description;
	private int discountPercentage;
	private boolean active;

}

/////////////
package com.booking.controller;

import com.booking.dto.PaymentResponseDTO;
import com.booking.entity.Payment;
import com.booking.service.PaymentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/payments")
public class PaymentController {

    @Autowired private PaymentService paymentService;

    @PostMapping public PaymentResponseDTO process(@RequestBody Payment payment) {
        Payment savedPayment = paymentService.processPayment(payment);
        PaymentResponseDTO response = new PaymentResponseDTO();
        response.setPaymentId(savedPayment.getPaymentId());
        response.setUserId(savedPayment.getUserId());
        response.setBookingId(savedPayment.getBookingId());
        response.setAmount(savedPayment.getAmount());
        response.setStatus(savedPayment.getStatus());
        response.setPaymentMethod(savedPayment.getPaymentMethod());
        response.setCurrency(savedPayment.getCurrency());
        return response;
    }

    @GetMapping public List<Payment> getAll() { return paymentService.getAllPayments(); }
    @GetMapping("/{id}") public Payment getById(@PathVariable Long id) { return paymentService.getPaymentById(id); }
}



package com.booking.dto;

public class PaymentResponseDTO {
    private Long paymentId;
    private Long userId;
    private Long bookingId;
    private double amount;
    private String status;
    private String paymentMethod;
    private String currency;

    // Getters and Setters
//////////////////////
package com.booking.service;
 
import com.booking.client.TravelPackageClient;
import com.booking.client.TravelInsuranceClient;
import com.booking.dto.OfferDTO;
import com.booking.dto.TravelPackageDTO;
import com.booking.entity.Booking;
import com.booking.entity.Payment;
import com.booking.repository.BookingRepository;
import com.booking.repository.PaymentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
import java.time.LocalDate;
import java.util.List;
 
@Service
public class PaymentService {
 
    @Autowired
    private PaymentRepository paymentRepo;
 
    @Autowired
    private BookingRepository bookingRepo;
 
    @Autowired
    private NotificationService notificationService;
 
    @Autowired
    private TravelPackageClient travelPackageClient;
 
    @Autowired
    private TravelInsuranceClient travelInsuranceClient;
 
    public Payment processPayment(Payment payment, String couponCodeApplied) {
        
        Long bookingId = payment.getBookingId();
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) {
            throw new IllegalArgumentException("Booking with ID " + bookingId + " not found.");
        }
 
        // Fetch package details
        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) {
            throw new IllegalArgumentException("Invalid package ID associated with booking.");
        }
        double packagePrice = pkg.getPrice();
        
        // Fetch insurance price for user
        double insurancePrice = 0.0;
        if (booking.getInsuranceId() != null && booking.getInsuranceId() > 0) {
        	insurancePrice = travelInsuranceClient.getInsurancePriceByUserId(booking.getUserId());
        }
        double discountAmount = 0.0;
 
        // Coupon logic via OfferDTO
        if (couponCodeApplied != null && pkg.getOffer() != null) {
            OfferDTO offer = pkg.getOffer();
         
            if (couponCodeApplied.equalsIgnoreCase(offer.getCouponCode()) && offer.isActive()) {
                discountAmount = (packagePrice * offer.getDiscountPercentage()) / 100.0;
                System.out.println("Coupon applied. Discount amount: " + discountAmount);
            }
        }
        
        double expectedTotal = packagePrice + insurancePrice - discountAmount;
 

        if (Math.abs(payment.getAmount() - expectedTotal) > 0.01) {
        	throw new IllegalArgumentException("Payment amount mismatch. Expected: " + expectedTotal);
        	}

 
        // Validate Card Details
        if (!payment.getPaymentMethod().equalsIgnoreCase("Credit Card") &&
            !payment.getPaymentMethod().equalsIgnoreCase("Debit Card")) {
            throw new IllegalArgumentException("Only Credit Card or Debit Card accepted.");
        }
 
        if (payment.getCardNumber() == null || !payment.getCardNumber().matches("\\d{16}")) {
            throw new IllegalArgumentException("Invalid card number.");
        }
 
        if (payment.getCvv() == null || !payment.getCvv().matches("\\d{3}")) {
            throw new IllegalArgumentException("Invalid CVV.");
        }
 
        if (payment.getAtmPin() == null || !payment.getAtmPin().matches("\\d{4}")) {
            throw new IllegalArgumentException("Invalid ATM PIN.");
        }
 
        if (payment.getExpiryDate() == null || !payment.getExpiryDate().matches("\\d{2}/\\d{2}")) {
            throw new IllegalArgumentException("Expiry date format invalid.");
        }
 
        String[] parts = payment.getExpiryDate().split("/");
        int expMonth = Integer.parseInt(parts[0]);
        int expYear = 2000 + Integer.parseInt(parts[1]);
 
        int currentMonth = LocalDate.now().getMonthValue();
        int currentYear = LocalDate.now().getYear();
 
        if (expMonth < 1 || expMonth > 12 || expYear < currentYear ||
           (expYear == currentYear && expMonth < currentMonth)) {
            throw new IllegalArgumentException("Card has expired.");
        }
 
        // Save payment
        payment.setStatus("PAID");
        Payment savedPayment = paymentRepo.save(payment);
 
        // Update booking with payment ID
        booking.setPaymentId(savedPayment.getPaymentId());
        bookingRepo.save(booking);
 
        // Update insurance record with booking ID if insurance selected
        if (insurancePrice > 0.0) {
            travelInsuranceClient.updateInsuranceBookingId(booking.getInsuranceId(), booking.getBookingId());
        }
 
        // Send Notifications
        notificationService.notifyCustomer(booking, savedPayment);
        notificationService.notifyTravelAgent(booking, savedPayment);
 
        return savedPayment;
    }
    
    public double calculateExpectedTotal(Long bookingId, String couponCodeApplied) {
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) throw new IllegalArgumentException("Booking not found");
     
        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) throw new IllegalArgumentException("Package not found");
     
        double packagePrice = pkg.getPrice();
        double insurancePrice = travelInsuranceClient.getInsurancePriceByUserId(booking.getUserId());
        double discountAmount = 0.0;
     
        if (couponCodeApplied != null && pkg.getOffer() != null) {
            OfferDTO offer = pkg.getOffer();
            if (couponCodeApplied.equalsIgnoreCase(offer.getCouponCode()) && offer.isActive()) {
                discountAmount = (packagePrice * offer.getDiscountPercentage()) / 100.0;
            }
        }
     
        return packagePrice + insurancePrice - discountAmount;
    }
    
    public List<Payment> getAllPayments() {
        return paymentRepo.findAll();
    }
 
    public Payment getPaymentById(Long id) {
        return paymentRepo.findById(id).orElse(null);
    }
}
 
package com.booking.controller;

import com.booking.dto.PaymentResponseDTO;
import com.booking.entity.Payment;
import com.booking.service.PaymentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.Collections;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/payments")
public class PaymentController {

    @Autowired private PaymentService paymentService;

    // Process payment with optional coupon code
    @PostMapping
    public PaymentResponseDTO process(
            @RequestBody Payment payment,
            @RequestParam(required = false) String couponCode) {
 
        Payment savedPayment = paymentService.processPayment(payment, couponCode);
 
        PaymentResponseDTO response = new PaymentResponseDTO();
        response.setPaymentId(savedPayment.getPaymentId());
        response.setUserId(savedPayment.getUserId());
        response.setBookingId(savedPayment.getBookingId());
        response.setAmount(savedPayment.getAmount());
        response.setStatus(savedPayment.getStatus());
        response.setPaymentMethod(savedPayment.getPaymentMethod());
        response.setCurrency(savedPayment.getCurrency());
 
        return response;
    }
    
 // Show total payable before actual payment
    @GetMapping("/expected-total")
    public Map<String, Double> getExpectedTotal(
            @RequestParam Long bookingId,
            @RequestParam(required = false) String couponCode) {
     
        double total = paymentService.calculateExpectedTotal(bookingId, couponCode);
        return Collections.singletonMap("totalPayable", total);
    }
    
    @GetMapping public List<Payment> getAll() { return paymentService.getAllPayments(); }
    
    @GetMapping("/{id}") public Payment getById(@PathVariable Long id) { return paymentService.getPaymentById(id); }
}

/////////////
package com.booking.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;

import java.util.List;
 
@FeignClient(name = "TravelInsuranceService")
public interface TravelInsuranceClient {
 
	@GetMapping("/api/insurance/price/{userId}")
    double getInsurancePriceByUserId(@PathVariable("userId") Long userId);
	
	@GetMapping("/api/insurance/validate/{insuranceId}")
	boolean validateInsurance(@PathVariable("insuranceId") Long insuranceId);
 
    @PutMapping("/api/insurance/{insuranceId}/booking/{bookingId}")
    String updateInsuranceBookingId(@PathVariable("insuranceId") Long insuranceId, @PathVariable("bookingId") Long bookingId);
}

///////////
@GetMapping("/price/{userId}")
    public ResponseEntity<Double> getInsurancePriceByUserId(@PathVariable Long userId) {
    logger.info("GET /api/insurance/price/{} - Fetching insurance price", userId);
     
        double price = service.getInsurancePriceByUserId(userId);
     
        if (price <= 0) {
            logger.warn("No insurance found for userId: {}", userId);
            return ResponseEntity.notFound().build();
        }
     
    logger.info("Insurance price for userId {} is {}", userId, price);
        return ResponseEntity.ok(price);
    }
    

public double getInsurancePriceByUserId(Long userId) {
        logger.info("Fetching insurance price for userId: {}", userId);

        List<Insurance> insurances = repo.findByUserId(userId);
        if (insurances.isEmpty()) {
            logger.warn("No insurance found for userId {}", userId);
            return 0.0;
        }

        Insurance insurance = insurances.get(0);

        if ("CANCELLED".equalsIgnoreCase(insurance.getIssuanceStatus())) {
            logger.info("Insurance is cancelled for userId {}", userId);
            return 0.0;
        }

        logger.info("Returning insurance price {} for insuranceId {}", insurance.getPrice(), insurance.getInsuranceId());
        return insurance.getPrice();
    }

///////////
@GetMapping("/price/insurance/{insuranceId}")
public ResponseEntity<Double> getInsurancePriceByInsuranceId(@PathVariable Long insuranceId) {
    logger.info("GET /api/insurance/price/insurance/{} - Fetching insurance price by insuranceId", insuranceId);

    double price = service.getInsurancePriceByInsuranceId(insuranceId);

    if (price <= 0) {
        logger.warn("No insurance found for insuranceId: {}", insuranceId);
        return ResponseEntity.notFound().build();
    }

    logger.info("Insurance price for insuranceId {} is {}", insuranceId, price);
    return ResponseEntity.ok(price);
}

public double getInsurancePriceByInsuranceId(Long insuranceId) {
    logger.info("Fetching insurance price for insuranceId: {}", insuranceId);

    Insurance insurance = repo.findById(insuranceId).orElse(null);

    if (insurance == null) {
        logger.warn("No insurance found for insuranceId {}", insuranceId);
        return 0.0;
    }

    if ("CANCELLED".equalsIgnoreCase(insurance.getIssuanceStatus())) {
        logger.info("Insurance is cancelled for insuranceId {}", insuranceId);
        return 0.0;
    }

    logger.info("Returning insurance price {} for insuranceId {}", insurance.getPrice(), insuranceId);
    return insurance.getPrice();
}

package com.example.travelinsuranceservice.repository;
 
import com.example.travelinsuranceservice.model.Insurance;
import org.springframework.data.jpa.repository.JpaRepository;
 
import java.util.List;
import java.util.Optional;
 
/**
 * Repository interface for Insurance entity.
 * Extends JpaRepository to get CRUD operations automatically.
 */
public interface InsuranceRepository extends JpaRepository<Insurance, Integer> {
 
    /**
     * Custom finder method to retrieve all insurance records for a given userId.
     * Spring Data JPA automatically generates the query from the method name.
     *
     * @param userId ID of the user
     * @return List of Insurance objects associated with the user
     */
    List<Insurance> findByUserId(Long userId);

	boolean existsByInsuranceId(Long insuranceId);

	Optional<Insurance> findById(Long insuranceId);
}

//entity
package com.example.travelinsuranceservice.model;
 
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
 
import java.time.LocalDateTime;
 
/**
 * Entity representing an insurance policy for travel booking.
 */
@Entity
@Data
public class Insurance {
 
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer insuranceId;
 
    @NotNull(message = "User ID cannot be null")
    private Long userId;
 
    // Booking ID will be updated later from the Booking module
    @Column(name="booking_id")
    private Long bookingId;
 
    @Enumerated(EnumType.STRING)
    @NotNull(message = "Coverage type is required")
    private CoverageType coverageType;
 
    // Fields populated based on coverageType at creation
    private String coverageDetails;
    private Double price;
    private Double claimableAmount;
 
    // Default Status Pending
    @Column(nullable=false)
    private String issuanceStatus = "PENDING";
    
    @Column(nullable=false)
    private String provider="Secure Travel Insurance Co.";
 
    @CreationTimestamp
    private LocalDateTime createdAt;
 
    /**
     * Automatically sets coverageDetails, price, and claimableAmount
     * before saving to DB based on the selected coverageType.
     */
    @PrePersist
    public void setDefaults() {
        if (coverageType != null) {
            this.coverageDetails = coverageType.getCoverageDetails();
            this.price = coverageType.getPrice();
            this.claimableAmount = coverageType.getClaimableAmount();
        }
    }
}
 

///////////
package com.example.travelinsuranceservice.repository;
 
import com.example.travelinsuranceservice.model.Insurance;
import org.springframework.data.jpa.repository.JpaRepository;
 
import java.util.List;
import java.util.Optional;
 
/**
 * Repository interface for Insurance entity.
 * Extends JpaRepository to get CRUD operations automatically.
 */
public interface InsuranceRepository extends JpaRepository<Insurance, Integer> {
 
    /**
     * Custom finder method to retrieve all insurance records for a given userId.
     * Spring Data JPA automatically generates the query from the method name.
     *
     * @param userId ID of the user
     * @return List of Insurance objects associated with the user
     */
    List<Insurance> findByUserId(Long userId);

	boolean existsByInsuranceId(Integer insuranceId);

	Optional<Insurance> findById(Integer insuranceId);
}
 

//////////////
package com.booking.service;
 
import com.booking.client.TravelPackageClient;
import com.booking.client.TravelInsuranceClient;
import com.booking.dto.OfferDTO;
import com.booking.dto.TravelPackageDTO;
import com.booking.entity.Booking;
import com.booking.entity.Payment;
import com.booking.repository.BookingRepository;
import com.booking.repository.PaymentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
import java.time.LocalDate;
import java.util.List;
 
@Service
public class PaymentService {
 
    @Autowired
    private PaymentRepository paymentRepo;
 
    @Autowired
    private BookingRepository bookingRepo;
 
    @Autowired
    private NotificationService notificationService;
 
    @Autowired
    private TravelPackageClient travelPackageClient;
 
    @Autowired
    private TravelInsuranceClient travelInsuranceClient;
 
    public Payment processPayment(Payment payment, String couponCodeApplied) {
        
        Long bookingId = payment.getBookingId();
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) {
            throw new IllegalArgumentException("Booking with ID " + bookingId + " not found.");
        }
 
        // Fetch package details
        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) {
            throw new IllegalArgumentException("Invalid package ID associated with booking.");
        }
        double packagePrice = pkg.getPrice();
        
        // Fetch insurance price for user
        double insurancePrice = 0.0;
        if (booking.getInsuranceId() != null && booking.getInsuranceId() > 0) {
        	insurancePrice = travelInsuranceClient.getInsurancePriceByUserId(booking.getUserId());
        }
        double discountAmount = 0.0;
 
        // Coupon logic via OfferDTO
        if (couponCodeApplied != null && pkg.getOffer() != null) {
            OfferDTO offer = pkg.getOffer();
         
            if (couponCodeApplied.equalsIgnoreCase(offer.getCouponCode()) && offer.isActive()) {
                discountAmount = (packagePrice * offer.getDiscountPercentage()) / 100.0;
                System.out.println("Coupon applied. Discount amount: " + discountAmount);
            }
        }
        
        double expectedTotal = packagePrice + insurancePrice - discountAmount;
 

        if (Math.abs(payment.getAmount() - expectedTotal) > 0.01) {
        	throw new IllegalArgumentException("Payment amount mismatch. Expected: " + expectedTotal);
        	}

 
        // Validate Card Details
        if (!payment.getPaymentMethod().equalsIgnoreCase("Credit Card") &&
            !payment.getPaymentMethod().equalsIgnoreCase("Debit Card")) {
            throw new IllegalArgumentException("Only Credit Card or Debit Card accepted.");
        }
 
        if (payment.getCardNumber() == null || !payment.getCardNumber().matches("\\d{16}")) {
            throw new IllegalArgumentException("Invalid card number.");
        }
 
        if (payment.getCvv() == null || !payment.getCvv().matches("\\d{3}")) {
            throw new IllegalArgumentException("Invalid CVV.");
        }
 
        if (payment.getAtmPin() == null || !payment.getAtmPin().matches("\\d{4}")) {
            throw new IllegalArgumentException("Invalid ATM PIN.");
        }
 
        if (payment.getExpiryDate() == null || !payment.getExpiryDate().matches("\\d{2}/\\d{2}")) {
            throw new IllegalArgumentException("Expiry date format invalid.");
        }
 
        String[] parts = payment.getExpiryDate().split("/");
        int expMonth = Integer.parseInt(parts[0]);
        int expYear = 2000 + Integer.parseInt(parts[1]);
 
        int currentMonth = LocalDate.now().getMonthValue();
        int currentYear = LocalDate.now().getYear();
 
        if (expMonth < 1 || expMonth > 12 || expYear < currentYear ||
           (expYear == currentYear && expMonth < currentMonth)) {
            throw new IllegalArgumentException("Card has expired.");
        }
 
        // Save payment
        payment.setStatus("PAID");
        Payment savedPayment = paymentRepo.save(payment);
 
        // Update booking with payment ID
        booking.setPaymentId(savedPayment.getPaymentId());
        bookingRepo.save(booking);
 
        // Update insurance record with booking ID if insurance selected
        if (insurancePrice > 0.0) {
            travelInsuranceClient.updateInsuranceBookingId(booking.getInsuranceId(), booking.getBookingId());
        }
 
        // Send Notifications
        notificationService.notifyCustomer(booking, savedPayment);
        notificationService.notifyTravelAgent(booking, savedPayment);
 
        return savedPayment;
    }
    
    public double calculateExpectedTotal(Long bookingId, String couponCodeApplied) {
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) throw new IllegalArgumentException("Booking not found");
     
        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) throw new IllegalArgumentException("Package not found");
     
        double packagePrice = pkg.getPrice();
        double insurancePrice = travelInsuranceClient.getInsurancePriceByUserId(booking.getUserId());
        double discountAmount = 0.0;
     
        if (couponCodeApplied != null && pkg.getOffer() != null) {
            OfferDTO offer = pkg.getOffer();
            if (couponCodeApplied.equalsIgnoreCase(offer.getCouponCode()) && offer.isActive()) {
                discountAmount = (packagePrice * offer.getDiscountPercentage()) / 100.0;
            }
        }
     
        return packagePrice + insurancePrice - discountAmount;
    }
    
    public List<Payment> getAllPayments() {
        return paymentRepo.findAll();
    }
 
    public Payment getPaymentById(Long id) {
        return paymentRepo.findById(id).orElse(null);
    }
}
 


////////////////////////////////////////////
package com.booking.service;

import com.booking.client.TravelPackageClient;
import com.booking.client.TravelInsuranceClient;
import com.booking.dto.OfferDTO;
import com.booking.dto.TravelPackageDTO;
import com.booking.entity.Booking;
import com.booking.entity.Payment;
import com.booking.repository.BookingRepository;
import com.booking.repository.PaymentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

@Service
public class PaymentService {

    @Autowired
    private PaymentRepository paymentRepo;

    @Autowired
    private BookingRepository bookingRepo;

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private TravelPackageClient travelPackageClient;

    @Autowired
    private TravelInsuranceClient travelInsuranceClient;

    public Payment processPayment(Payment payment, String couponCodeApplied) {

        Long bookingId = payment.getBookingId();
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) {
            throw new IllegalArgumentException("Booking with ID " + bookingId + " not found.");
        }

        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) {
            throw new IllegalArgumentException("Invalid package ID associated with booking.");
        }

        double packagePrice = pkg.getPrice();

        double insurancePrice = 0.0;
        if (booking.getInsuranceId() != null && booking.getInsuranceId() > 0) {
            insurancePrice = travelInsuranceClient.getInsurancePriceByInsuranceId(booking.getInsuranceId().intValue());
        }

        double discountAmount = 0.0;
        if (couponCodeApplied != null && pkg.getOffer() != null) {
            OfferDTO offer = pkg.getOffer();
            if (couponCodeApplied.equalsIgnoreCase(offer.getCouponCode()) && offer.isActive()) {
                discountAmount = (packagePrice * offer.getDiscountPercentage()) / 100.0;
                System.out.println("Coupon applied. Discount amount: " + discountAmount);
            }
        }

        double expectedTotal = packagePrice + insurancePrice - discountAmount;

        if (Math.abs(payment.getAmount() - expectedTotal) > 0.01) {
            throw new IllegalArgumentException("Payment amount mismatch. Expected: " + expectedTotal);
        }

        if (!payment.getPaymentMethod().equalsIgnoreCase("Credit Card") &&
            !payment.getPaymentMethod().equalsIgnoreCase("Debit Card")) {
            throw new IllegalArgumentException("Only Credit Card or Debit Card accepted.");
        }

        if (payment.getCardNumber() == null || !payment.getCardNumber().matches("\\d{16}")) {
            throw new IllegalArgumentException("Invalid card number.");
        }

        if (payment.getCvv() == null || !payment.getCvv().matches("\\d{3}")) {
            throw new IllegalArgumentException("Invalid CVV.");
        }

        if (payment.getAtmPin() == null || !payment.getAtmPin().matches("\\d{4}")) {
            throw new IllegalArgumentException("Invalid ATM PIN.");
        }

        if (payment.getExpiryDate() == null || !payment.getExpiryDate().matches("\\d{2}/\\d{2}")) {
            throw new IllegalArgumentException("Expiry date format invalid.");
        }

        String[] parts = payment.getExpiryDate().split("/");
        int expMonth = Integer.parseInt(parts[0]);
        int expYear = 2000 + Integer.parseInt(parts[1]);

        int currentMonth = LocalDate.now().getMonthValue();
        int currentYear = LocalDate.now().getYear();

        if (expMonth < 1 || expMonth > 12 || expYear < currentYear ||
           (expYear == currentYear && expMonth < currentMonth)) {
            throw new IllegalArgumentException("Card has expired.");
        }

        payment.setStatus("PAID");
        Payment savedPayment = paymentRepo.save(payment);

        booking.setPaymentId(savedPayment.getPaymentId());
        bookingRepo.save(booking);

        if (insurancePrice > 0.0) {
            travelInsuranceClient.updateInsuranceBookingId(booking.getInsuranceId().intValue(), booking.getBookingId());
        }

        notificationService.notifyCustomer(booking, savedPayment);
        notificationService.notifyTravelAgent(booking, savedPayment);

        return savedPayment;
    }

    public double calculateExpectedTotal(Long bookingId, String couponCodeApplied) {
        Booking booking = bookingRepo.findById(bookingId).orElse(null);
        if (booking == null) throw new IllegalArgumentException("Booking not found");

        TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
        if (pkg == null) throw new IllegalArgumentException("Package not found");

        double packagePrice = pkg.getPrice();

        double insurancePrice = 0.0;
        if (booking.getInsuranceId() != null && booking.getInsuranceId() > 0) {
            insurancePrice = travelInsuranceClient.getInsurancePriceByInsuranceId(booking.getInsuranceId().intValue());
        }

        double discountAmount = 0.0;
        if (couponCodeApplied != null && pkg.getOffer() != null) {
            OfferDTO offer = pkg.getOffer();
            if (couponCodeApplied.equalsIgnoreCase(offer.getCouponCode()) && offer.isActive()) {
                discountAmount = (packagePrice * offer.getDiscountPercentage()) / 100.0;
            }
        }

        return packagePrice + insurancePrice - discountAmount;
    }

    public List<Payment> getAllPayments() {
        return paymentRepo.findAll();
    }

    public Payment getPaymentById(Long id) {
        return paymentRepo.findById(id).orElse(null);
    }
}

//////////28/06/2025

POST http://localhost:8080/api/payments
postamn input 
Body raw JSON
{
    "userId":4,
    "bookingId":5,
    "amount":50999.0,
    "paymentMethod": "Debit Card",
    "currency":"INR",
    "cardNumber": "1111222233334444",
    "atmPin": "0001",
    "cvv": "001",
    "expiryDate": "04/28"   
}

postman response
{
    "timestamp": "2025-06-28T06:31:03.231+00:00",
    "status": 500,
    "error": "Internal Server Error",
    "path": "/api/payments"
}

///////////////

 Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: feign.FeignException$Forbidden: [403] during [GET] to [http://usermanagement-service/api/users/internal/customer/3] [UserClient#getCustomerById(Long)]: [{"message":"User with ID 3 is not an CUSTOMER"}]] with root cause

feign.FeignException$Forbidden: [403] during [GET] to [http://usermanagement-service/api/users/internal/customer/3] [UserClient#getCustomerById(Long)]: [{"message":"User with ID 3 is not an CUSTOMER"}]
	at feign.FeignException.clientErrorStatus(FeignException.java:247) ~[feign-core-13.5.jar:na]
	at feign.FeignException.errorStatus(FeignException.java:223) ~[feign-core-13.5.jar:na]
	at feign.FeignException.errorStatus(FeignException.java:213) ~[feign-core-13.5.jar:na]
	at feign.codec.ErrorDecoder$Default.decode(ErrorDecoder.java:103) ~[feign-core-13.5.jar:na]
	at feign.InvocationContext.decodeError(InvocationContext.java:133) ~[feign-core-13.5.jar:na]
	at feign.InvocationContext.proceed(InvocationContext.java:80) ~[feign-core-13.5.jar:na]
	at feign.ResponseHandler.handleResponse(ResponseHandler.java:69) ~[feign-core-13.5.jar:na]
	at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:109) ~[feign-core-13.5.jar:na]
	at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:53) ~[feign-core-13.5.jar:na]
	at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:104) ~[feign-core-13.5.jar:na]
	at jdk.proxy2/jdk.proxy2.$Proxy146.getCustomerById(Unknown Source) ~[na:na]
	at com.booking.service.NotificationService.notifyTravelAgent(NotificationService.java:52) ~[classes/:na]
	at com.booking.service.PaymentService.processPayment(PaymentService.java:121) ~[classes/:na]
	at com.booking.controller.PaymentController.process(PaymentController.java:26) ~[classes/:na]
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:258) ~[spring-web-6.2.7.jar:6.2.7]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:191) ~[spring-web-6.2.7.jar:6.2.7]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118) ~[spring-webmvc-6.2.7.jar:6.2.7]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986) ~[spring-webmvc-6.2.7.jar:6.2.7]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891) ~[spring-webmvc-6.2.7.jar:6.2.7]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-6.2.7.jar:6.2.7]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089) ~[spring-webmvc-6.2.7.jar:6.2.7]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979) ~[spring-webmvc-6.2.7.jar:6.2.7]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) ~[spring-webmvc-6.2.7.jar:6.2.7]
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914) ~[spring-webmvc-6.2.7.jar:6.2.7]
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590) ~[tomcat-embed-core-10.1.41.jar:6.0]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885) ~[spring-webmvc-6.2.7.jar:6.2.7]
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658) ~[tomcat-embed-core-10.1.41.jar:6.0]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) ~[tomcat-embed-websocket-10.1.41.jar:10.1.41]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-6.2.7.jar:6.2.7]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.2.7.jar:6.2.7]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-6.2.7.jar:6.2.7]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.2.7.jar:6.2.7]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-6.2.7.jar:6.2.7]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.2.7.jar:6.2.7]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:116) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:398) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at java.base/java.lang.Thread.run(Thread.java:1583) ~[na:na]

[2m2025-06-28T12:27:26.279+05:30[0;39m [32mDEBUG[0;39m [35m46644[0;39m [2m--- [TravelBooking-PaymentModule] [nio-8086-exec-9] [0;39m[36mo.s.web.servlet.DispatcherServlet       [0;39m [2m:[0;39m "ERROR" dispatch for POST "/error", parameters={}
[2m2025-06-28T12:27:26.279+05:30[0;39m [32mDEBUG[0;39m [35m46644[0;39m [2m--- [TravelBooking-PaymentModule] [nio-8086-exec-9] [0;39m[36ms.w.s.m.m.a.RequestMappingHandlerMapping[0;39m [2m:[0;39m Mapped to org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController#error(HttpServletRequest)
[2m2025-06-28T12:27:26.279+05:30[0;39m [32mDEBUG[0;39m [35m46644[0;39m [2m--- [TravelBooking-PaymentModule] [nio-8086-exec-9] [0;39m[36mo.j.s.OpenEntityManagerInViewInterceptor[0;39m [2m:[0;39m Opening JPA EntityManager in OpenEntityManagerInViewInterceptor
[2m2025-06-28T12:27:26.280+05:30[0;39m [32mDEBUG[0;39m [35m46644[0;39m [2m--- [TravelBooking-PaymentModule] [nio-8086-exec-9] [0;39m[36mo.s.w.s.m.m.a.HttpEntityMethodProcessor [0;39m [2m:[0;39m Using 'application/json', given [*/*] and supported [application/json, application/*+json]
[2m2025-06-28T12:27:26.280+05:30[0;39m [32mDEBUG[0;39m [35m46644[0;39m [2m--- [TravelBooking-PaymentModule] [nio-8086-exec-9] [0;39m[36mo.s.w.s.m.m.a.HttpEntityMethodProcessor [0;39m [2m:[0;39m Writing [{timestamp=

java.io.EOFException: null
	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.fillReadBuffer(NioEndpoint.java:1295) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.read(NioEndpoint.java:1183) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:781) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:345) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:271) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:903) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1189) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:658) ~[tomcat-embed-core-10.1.41.jar:10.1.41]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskTh

////////////////////////////sending
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(CustomBusinessException.class)
    public ResponseEntity<?> handleBusinessError(CustomBusinessException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(FeignException.class)
    public ResponseEntity<?> handleFeignError(FeignException ex) {
        return ResponseEntity.status(ex.status()).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGeneralError(Exception ex) {
        log.error("Unhandled error: ", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "Unexpected error occurred", "details", ex.getMessage()));
    }
}



try {
    userClient.getCustomerById(userId);
} catch (FeignException.Forbidden e) {
    log.error("Forbidden from UserService: {}", e.getMessage());
    throw new CustomBusinessException("User is not a CUSTOMER");
}


import feign.FeignException;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class PaymentService {

    // Autowired fields...

    public Payment processPayment(Payment payment, String couponCodeApplied) {
        Long bookingId = payment.getBookingId();
        Long userId = payment.getUserId();
        double paidAmount = payment.getAmount();

        log.info("Initiating payment for bookingId={}, userId={}, amount={}", bookingId, userId, paidAmount);

        Booking booking = bookingRepo.findById(bookingId)
                .orElseThrow(() -> {
                    log.warn("Booking not found for ID: {}", bookingId);
                    return new CustomBusinessException("Booking not found with ID: " + bookingId);
                });

        double totalPayable = booking.getTotalPayableAmount();
        log.debug("Booking ID {} - Total Payable Amount = {}", bookingId, totalPayable);

        if (Math.abs(paidAmount - totalPayable) > 0.01) {
            log.warn("Payment mismatch for bookingId={}: paid={}, expected={}", bookingId, paidAmount, totalPayable);
            throw new CustomBusinessException("Payment amount mismatch. Please pay the exact amount.");
        }

        try {
            // Validate package existence
            TravelPackageDTO pkg = travelPackageClient.getPackageById(booking.getPackageId());
            log.debug("Fetched travel package: {}", pkg.getPackageName());
        } catch (FeignException e) {
            log.error("Failed to fetch travel package for ID {}: {}", booking.getPackageId(), e.getMessage());
            throw new CustomBusinessException("Invalid travel package ID or package service unavailable.");
        }

        try {
            // Save payment
            payment.setDate(LocalDate.now());
            Payment saved = paymentRepo.save(payment);
            log.info("Payment saved successfully: ID = {}", saved.getPaymentId());

            // Send notifications
            notificationService.notifyUser(userId, bookingId, paidAmount);
            notificationService.notifyTravelAgent(userId, bookingId);

            return saved;

        } catch (FeignException e) {
            log.error("Notification failed: {}", e.getMessage());
            throw new CustomBusinessException("Payment succeeded but notification failed. Support will contact you.");
        } catch (Exception ex) {
            log.error("Unexpected error while processing payment: {}", ex.getMessage(), ex);
            throw new CustomBusinessException("Unexpected error occurred during payment.");
        }
    }
}
/////////////////////
package com.booking.exception;

import java.util.Map;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import feign.FeignException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestControllerAdvice
public class GlobalExceptionHandler {
	
	 private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);
	
    @ExceptionHandler(CustomBusinessException.class)
    public ResponseEntity<?> handleBusinessError(CustomBusinessException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(FeignException.class)
    public ResponseEntity<?> handleFeignError(FeignException ex) {
        return ResponseEntity.status(ex.status()).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGeneralError(Exception ex) {
        log.error("Unhandled error: ", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "Unexpected error occurred", "details", ex.getMessage()));
    }
}

///////////sending
package com.booking.exception;

/**
 * Custom exception used to indicate business rule violations or validation failures
 * that should result in a 400 Bad Request error.
 */
public class CustomBusinessException extends RuntimeException {

    public CustomBusinessException(String message) {
        super(message);
    }

    public CustomBusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}
